101、Struts 2中的默认包struts-default有什么作用？

答：它定义了Struts 2内部的众多拦截器和Result类型，而Struts 2很多核心的功能都是通过这些内置的拦截器实现，如：从请求中把请求参数封装到action、文件上传和数据验证等等都是通过拦截器实现的。在Struts 2的配置文件中，自定义的包继承了struts-default包就可以使用Struts 2为我们提供的这些功能。

 

102、简述值栈(Value-Stack)的原理和生命周期

答：Value-Stack贯穿整个 Action 的生命周期，保存在request作用域中，所以它和request的生命周期一样。当Struts 2接受一个请求时，会创建ActionContext、Value-Stack和Action对象，然后把Action存放进Value-Stack，所以Action的实例变量可以通过OGNL访问。由于Action是多实例的，和使用单例的Servlet不同，  每个Action都有一个对应的Value-Stack，Value-Stack存放的数据类型是该Action的实例，以及该Action中的实例变量，Action对象默认保存在栈顶。

 

103、SessionFactory是线程安全的吗？Session是线程安全的吗，两个线程能够共享同一个Session吗？

答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例的模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal来取得当前的session，无论你调用多少次getCurrentSession()方法，返回的都是同一个session。

 

104、Session的load和get方法的区别是什么？

答：主要有以下三项区别：

1) 如果没有找到符合条件的记录, get方法返回null,load方法抛出异常

2) get方法直接返回实体类对象, load方法返回实体类对象的代理

3) get方法只在一级缓存(内部缓存)中进行数据查找, 如果没有找到对应的数据则越过二级缓存, 直接发出SQL语句完成数据读取; load方法则可以充分利用二级缓存中的现有数据

简单的说，对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法去取的数据可以不存在。

 

105、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法有什么区别？

答：Hibernate的对象有三种状态：瞬态、持久态和游离态。游离状态的实例可以通过调用save()、persist()或者saveOrUpdate()方法进行持久化；脱管状态的实例可以通过调用 update()、0saveOrUpdate()、lock()或者replicate()进行持久化。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。merge方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。按照官方文档的说明：(1)persist()方法把一个瞬态的实例持久化，但是并"不保证"标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；(2) persist"保证"，当它在一个事务外部被调用的时候并不触发一个Insert语句，当需要封装一个长会话流程的时候，一个persist这样的函数是需要的。(3)save"不保证"第2条,它要返回标识符，所以它会立即执行Insert语句，不管是不是在事务内部还是外部。update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。

 

106、阐述Session加载实体对象的过程。

答：Session加载实体对象的步骤是：

1) Session在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回

2) 如果一级缓存没有命中, 接下来Session会在当前NonExists记录(相当于一个查询黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果NonExists中存在同样的查询条件,则返回null

3) 对于load方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接返回

4) 如果之前的查询都未命中, 则发出SQL语句, 如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录, 并返回null

5) 根据映射配置和SQL语句得到ResultSet,并创建对应的实体对象

6) 将对象纳入Session(一级缓存)管理

7) 执行拦截器的onLoad方法(如果有对应的拦截器)

8) 将数据对象纳入二级缓存

9) 返回数据对象

 

107、Query接口的list方法和iterate方法有什么区别？

答：

1) list方法无法利用缓存,它对缓存只写不读; iterate方法可以充分利用缓存, 如果目标数据只读或者读取频繁, iterate可以减少性能开销

2) list方法不会引起N+1查询问题, 而iterate方法会引起N+1查询问题

 

108、Hibernate如何实现分页查询？

答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句、查询起始行数(setFirstresult()方法)和最大查询行数(setMaxResult()方法)，并调用Query接口的list()方法，Hibernate会自动生成分页查询的SQL语句。

 

109、锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。

答：有些业务逻辑在执行过程中往往需要保证数据访问的排他性，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。

Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义，它悲观的认为在数据处理过程中一定存在修改数据的并发事务(包括本系统的其他事务或来自外部系统的事务)，于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性。乐观锁，顾名思义，对并发事务持乐观态度(认为对数据的并发操作很少发生)，通过更加宽松的锁机制解决悲观锁排他的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据。

 

110、阐述实体对象的三种状态以及转换关系。

答：Hibernate中对象有三种状态：临时态（transient）、持久态（persistent）和游状态（detached），如下图所示。


图 Hibernate实体状态转换图

ü 临时状态：当new一个实体对象后，这个对象处于临时状态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save或者saveOrUpdate把临时对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久对象。

ü 持久状态：持久化对象的实例在数据库中有对应的记录，并拥有一个持久化标识。对持久化对象进行delete操作后，数据库中对应的记录将被删除，那么持久化对象与数据库记录不再存在对应关系，持久化对象变成临时状态。持久化对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。

ü 游离状态：当Session进行了close、clear或者evict后，持久化对象虽然拥有持久化标识符和与数据库对应记录一致的值，但是因为会话已经消失，对象不在持久化管理之内，所以处于游离状态（也叫脱管状态）。游离状态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。

 

111、如何理解Hibernate的延迟加载机制。在实际应用中，延迟加载与session关闭的矛盾是如何处理的？

答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载。返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时就会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。

延迟加载与session关闭的矛盾一般可以这样处理：

1) 关闭延迟加载特性。这种方式操作起来比较简单，因为hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现no session or session wasclosed就证明了系统中已经存在主外键关联，如果去掉延迟加载的话，则每次查询的开销都会变得很大。

2) 在session关闭之前先获取需要查询的数据(Hibernate.initialize()方法)。

3) 使用拦截器(Interceptor)或过滤器(Filter)控制Session。

 

112、举一个多对多关联的例子，并说明如何实现多对多关联映射。

答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的<set>和<many-to-many>标签配置多对多关联，但是通常情况下，可以将多对多关联转换成两个多对一关联来实现多对多关联映射。

 

113、谈一下你对继承映射的理解。

答：继承关系的映射策略有三种：

1) 每个继承结构一张表(table per class hierarchy)

2) 每个子类一张表(table per subclass)

3) 每个具体类一张表(table per concrete class)

第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。

 

114、简述Hibernate常见优化策略。

答：

1) 制定合理的缓存策略

2) 采用合理的Session管理机制

3) 尽量使用延迟加载特性

4) 设定合理的批处理参数

5) 如果可以, 选用UUID作为主键生成器

6) 如果可以, 选用基于version的乐观锁替代悲观锁

7) 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL, 从而了解底层的状况;开发完成后关闭此选项

8) 数据库本身的优化(合理的索引, 缓存, 数据分区策略等)也会对持久层的性能带来可观的提升, 这些需要专业的DBA提供支持

 

115、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。

答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。

SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类(可以使用第三方提供的实现)。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。

一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。

116、说出Servlet的生命周期，并说出Servlet和CGI的区别?

答：Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet、doPost等），当服务器决定将实例销毁的时候调用其destroy方法。Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。

补充：目前使用的Fast CGI已经解决了CGI效率上的问题，所以面试的时候大可不必诟病CGI，腾讯的网站就使用了CGI技术，也没感觉它哪里不好。

 

117、转发（forward）和重定向（redirect）的区别?

答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址。前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接；在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。

 

118、JSP有哪些内置对象？作用分别是什么？

答：JSP有9个内置对象：

request：封装客户端的请求，其中包含来自GET或POST请求的参数；

response：封装服务器对客户端的响应；

pageContext：通过该对象可以获取其他对象；

session：封装用户会话的对象；

application：封装服务器运行环境的对象；

out：输出服务器响应的输出流对象；

config：Web应用的配置对象；

page：JSP页面本身（相当于Java程序中的this）；

exception：封装页面抛出异常的对象。

 

119、get和post请求的区别？

答：

1)get请求用来从服务器上获得资源，而post是用来向服务器提交数据；

2)get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；post是将表单中的数据放在HTML头部（header），传递到action所指向URL；

3)get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件只能使用post方式；

4)使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；

5)get使用MIME类型application/x-www-form-urlencoded的URL 编码（URL encoding，也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是"%20"。

 

120、常用的Web容器

答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常用服务器的简介：

IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。

Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。

WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。

WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。

Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。

Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。

 

121、JSP 和Servlet 有有什么关系？

答：Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。

 

122、JSP中的四种作用范围？

答：page、request、session和application，具体如下：

1)page 代表与一个页面相关的对象和属性；

2)request 代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web 组件；

3)session代表与某个用户与服务器建立的一次会话相关的对象和属性；

4)application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。

 

123、如何实现JSP或Servlet的单线程模式？

答：<%@page isThreadSafe=”false”%>

补充：Servlet默认的工作模式是单实例多线程，如果Servlet实现了标识接口SingleThreadModel又或是JSP页面通过page指令设置isThreadSafe属性为false，那么它们生成的Java代码会以单线程多实例方式工作。显然，这样做会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题。

 

124、实现会话跟踪的技术有哪些？

答：由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。

cookie：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中。

URL 重写：将唯一的会话ID添加到URL结尾以标识一个会话。

设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。

 

126、过滤器有哪些作用和用法？

答： Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。

常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。

和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain

下面是编码过滤器的例子：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.accp.filter;  
       
    import java.io.IOException;  
       
    import javax.servlet.Filter;  
    import javax.servlet.FilterChain;  
    import javax.servlet.FilterConfig;  
    import javax.servlet.ServletException;  
    import javax.servlet.ServletRequest;  
    import javax.servlet.ServletResponse;  
       
    public class CodingFilter implements Filter {  
      privateString defaultEncoding = "utf-8";  
       
      @Override  
      publicvoid destroy() {  
      }  
       
      @Override  
      publicvoid doFilter(ServletRequest req, ServletResponse resp,  
           FilterChainchain) throws IOException, ServletException {  
         req.setCharacterEncoding(defaultEncoding);  
         resp.setCharacterEncoding(defaultEncoding);  
         chain.doFilter(req,resp);  
      }  
       
      @Override  
      publicvoid init(FilterConfig config) throws ServletException {  
         Stringencoding = config.getInitParameter("encoding");  
         if(encoding!= null) {  
           defaultEncoding= encoding;  
         }  
      }  
    }  


 

127、监听器有哪些作用和用法？

答：Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：

1)ServletContextListener：对Servlet上下文的创建和销毁进行监听。

2)ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。

3)HttpSessionListener：对Session的创建和销毁进行监听。

补充：session的销毁有两种情况：1session超时（可以在web.xml中通过<session-config>/<session-timeout>标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。

4)HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。

5)ServletRequestListener：对请求对象的初始化和销毁进行监听。

6)ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。

下面是一个统计网站最多在线人数及时间的监听器：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.listener;  
       
    import java.text.DateFormat;  
    import java.text.SimpleDateFormat;  
    import java.util.Date;  
       
    import javax.servlet.ServletContext;  
    import javax.servlet.http.HttpSessionEvent;  
    import javax.servlet.http.HttpSessionListener;  
       
    public class MaxCountListener implementsHttpSessionListener {  
       
      @Override  
      publicvoid sessionCreated(HttpSessionEvent event) {  
         ServletContextapp = event.getSession().getServletContext();  
         intcount = Integer.parseInt(app.getAttribute("onLineCount").toString());  
         count++;  
         app.setAttribute("onLineCount",count);  
         intmaxOnLineCount =Integer.parseInt(app.getAttribute("maxOnLineCount").toString());  
         if(count > maxOnLineCount) {  
           app.setAttribute("maxOnLineCount",count);  
           DateFormatdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
           app.setAttribute("date",df.format(new Date()));  
         }  
      }  
       
      @Override  
      publicvoid sessionDestroyed(HttpSessionEvent event) {  
         ServletContextapp = event.getSession().getServletContext();  
         intcount = Integer.parseInt(app.getAttribute("onLineCount").toString());  
         count--;  
         app.setAttribute("onLineCount",count);  
      }  
    }  
       


128、web.xml 的作用？

答：用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。例如：

1)配置Spring上下文加载监听器加载Spring配置文件：

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <context-param>  
         <param-name>contextConfigLocation</param-name>  
        <param-value>classpath:applicationContext.xml</param-value>  
      </context-param>  
       
      <listener>  
         <listener-class>  
           org.springframework.web.context.ContextLoaderListener  
         </listener-class>  
      </listener>  


2)配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <filter>  
      <filter-name>openSessionInView</filter-name>  
      <filter-class>  
         org.springframework.orm.hibernate3.support.OpenSessionInViewFilter  
      </filter-class>  
    </filter>  
       
    <filter-mapping>  
      <filter-name>openSessionInView</filter-name>  
      <url-pattern>/*</url-pattern>  
    </filter-mapping>  


3)配置会话超时时间为10分钟：

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <session-config>  
    <session-timeout>10</session-timeout>  
    </session-config>  


4)配置404和Exception的错误页面：

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <error-page>  
      <error-code>404</error-code>  
      <location>/error.jsp</location>  
    </error-page>  
       
    <error-page>  
      <exception-type>java.lang.Exception</exception-type>  
      <location>/error.jsp</location>  
    </error-page>  


5)配置安全认证方式：

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <security-constraint>  
    <web-resource-collection>  
          <web-resource-name>ProtectedArea</web-resource-name>  
          <url-pattern>/admin/*</url-pattern>  
          <http-method>GET</http-method>  
          <http-method>POST</http-method>  
      </web-resource-collection>  
    <auth-constraint>  
    <role-name>admin</role-name>  
    </auth-constraint>  
    </security-constraint>  
       
    <login-config>  
      <auth-method>BASIC</auth-method>  
    </login-config>  
       
    <security-role>  
    <role-name>admin</role-name>  
    </security-role>  


补充：如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类：

A.What you know?  --- 口令

B.What you have? --- 数字证书（U盾、密保卡）

C.Who you are? ---  指纹、虹膜

在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。

 

129、你的项目中使用过哪些JSTL标签？

答：项目中主要使用了JSTL的核心标签库，包括<c:if>、<c:choose>、<c: when>、<c: otherwise>、<c:forEach>等，主要用于构造循环和分支结构以控制显示逻辑。

说明：虽然JSTL标签库提供了core、sql、fmt、xml等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。

 

130、使用标签库有什么好处？如何自定义JSP标签？

答：使用标签库的好处包括以下几个方面：

1)分离JSP页面的内容和逻辑，简化了Web开发；

2)开发者可以创建自定义标签来封装业务逻辑和显示逻辑；

3)标签具有很好的可移植性、可维护性和可重用性；

4)避免了对Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在JSP中书写小脚本）

自定义JSP标签包括以下几个步骤：

A.编写一个Java类实现实现Tag/BodyTag/IterationTag接口(通常不直接实现这些接口而是继承TagSupport/BodyTagSupport/SimpleTagSupport类，这是对适配器模式中缺省适配模式的应用)

B.重写doStartTag()、doEndTag()等方法，定义标签要完成的功能

C.编写扩展名为tld的标签描述文件对自定义标签进行部署，tld文件通常放在WEB-INF文件夹或其子目录

D.如果要将标签库做成JAR文件，可以使用打包命令jarcvf filename.jar . [最后的点是必要的，还要注意路径问题]；tld文件放在JAR文件的META-INF目录，然后将JAR文件放到项目的WEB-INF/lib目录下

E.在web.xml文件中使用<jsp-config>标签配置自定义标签库

F.在JSP页面中使用taglib指令引用该标签库

下面是一个例子：

标签类源代码

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.tag;  
       
    import java.io.IOException;  
    import java.text.SimpleDateFormat;  
    import java.util.Date;  
       
    import javax.servlet.jsp.JspException;  
    import javax.servlet.jsp.JspWriter;  
    import javax.servlet.jsp.tagext.TagSupport;  
       
    @SuppressWarnings("serial")  
    public class TimeTag extends TagSupport {  
      privateString format = "yyyy-MM-dd hh:mm:ss";  
      privateString foreColor = "black";  
      privateString backColor = "white";  
       
      public intdoStartTag() throws JspException {  
         SimpleDateFormatsdf = new SimpleDateFormat(format);  
         JspWriterwriter = pageContext.getOut();  
         StringBuildersb = new StringBuilder();  
         sb.append(String.format("<spanstyle='color:%s;background-color:%s'>%s</span>",  
             foreColor,backColor, sdf.format(new Date())));  
         try {  
           writer.print(sb.toString());  
         } catch(IOException e) {  
           e.printStackTrace();  
         }  
         returnSKIP_BODY;  
      }  
       
      publicvoid setFormat(String format) {  
         this.format= format;  
      }  
       
      publicvoid setForeColor(String foreColor) {  
         this.foreColor= foreColor;  
      }  
       
      publicvoid setBackColor(String backColor) {  
         this.backColor= backColor;  
      }  
    }  


 

标签描述文件

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <?xml version="1.0"encoding="UTF-8" ?>  
    <taglibxmlnstaglibxmlns="http://java.sun.com/xml/ns/j2ee"  
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
      xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee  
    http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"  
    version="2.0">  
      <tlib-version>1.0</tlib-version>  
      <short-name>JTag</short-name>  
      <tag>  
         <name>time</name>  
         <tag-class>com.jackfrued.tag.TimeTag</tag-class>  
         <body-content>empty</body-content>  
         <attribute>  
           <name>format</name>  
           <required>false</required>  
         </attribute>  
         <attribute>  
           <name>foreColor</name>  
         </attribute>  
         <attribute>  
           <name>backColor</name>  
         </attribute>  
      </tag>  
    </taglib>  


 

Web.xml配置

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <jsp-config>  
      <taglib>  
    <taglib-uri>http://blog.csdn.net/jackfrued/mytaglib</taglib-uri>  
         <taglib-location>/WEB-INF/tld/mytag.tld</taglib-location>  
      </taglib>  
    </jsp-config>  
       


JSP页面

[html] view plaincopy在CODE上查看代码片派生到我的代码片

    <%@taglib prefix="j"uri="http://blog.csdn.net/jackfrued/mytaglib" %>  
    <j:timeformatj:timeformat="yyyy-MM-dd hh:mm" foreColor="yellow"backColor="blue"/> 
    
131、请对以下Java EE中的名词进行解释

答：

A.容器：容器为Java EE应用程序组件提供了运行时支持。容器提供了一份从底层Java EE API到应用程序组件的联合视图。Java EE应用程序组件不能直接地与其它Java EE应用程序组件交互。它们通过容器的协议和方法来达成它们之间以及它们与平台服务之间的交互。在应用程序组件和Java EE服务之间插入一个容器，这允许该容器透明地为组件注入必须的服务，例如声明式事务管理，安全检查，资源池和状态管理。

B.资源适配器：资源适配器是一个系统级的组件，它通常实现了对外部资源管理器的网络连接。资源适配器能够扩展Java EE平台的功能。这只需要实现一个Java EE标准服务API(例如JDBCTM驱动程序)，或者定义并实现一个能连接到外部应用程序系统的资源适配器就可以达到。资源适配器也可以提供完整的本地或本地资源的服务。资源适配器接口通过Java EE服务供应商接口(Java EE SPI)来连接Java EE平台。使用Java EE SPI连接到Java EE平台的资源适配器可以和所有的Java EE产品协同工作。

C.JNDI（Java Naming & Directory Interface）：JAVA命名目录接口，主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。

D.JMS（Java Message Service）：Java消息服务是用于消息发送的标准API，它支持可靠的“点对点”消息发送和“发布-订阅”模型。Java EE规范要求JMS供应商同时实现“点对点”消息发送和”发布/订阅”型消息发送。

E.JTA（Java Transaction API）：Java 事务接口。Java事务API由两部分组成：1)一个应用程序级的边界划分接口，容器和应用程序组件用它来划分事务边界；2)一个介于事务管理器和资源管理器之间的Java EE SPI级接口。

F.JPA（Java Persistence API）：Java持久化API是用于持久化和对象/关系映射管理的标准API。通过使用一个Java域模型来管理关系型数据库，Java EE规范为应用程序开发者提供了一种对象/关系映射功能。Java EE必须对Java持久化API提供支持。它也可以用在JavaSE环境中。

G.JAF（JavaBean Activation FrameWork）：JAFAPI提供了一个框架来处理不同MIME类型的数据，它们源于不同的格式和位置。JavaMail API使用了JAF API。JAFAPI包含在Java SE中，因此它可以被JavaEE应用程序使用。

H.JAAS（Java Authentication and Authorization Service）：使服务能够基于用户进行验证和实施访问控制。它实现了一个Java版的标准的的Plugable Authentication Module (PAM)框架，并支持基于用户的授权。JavaTM Authorization Service Provider Contract for Containers (JACC) 定义了Java EE应用程序服务器和授权服务提供方之间的协议，允许将自定义的授权服务提供方插入任何JavaEE产品中。

I.JMX（Java Management Extension）：Java平台企业版管理规范中定义了一种API，通过一种特殊的管理型EJB来管理Java EE服务器。JMX API也提供了一些管理上的支持。

 

132、Java EE 是什么？

答：Java EE是Sun公司为企业级应用推出的标准平台，该平台是由一系列技术标准所组成的，包括：EJB、JAAS、JAF、JAX-WS、JDBC、JNDI、JSTL、JSF、JSP、Servlet、RMI等。

 

133、你是如何理解控制反转（IoC）和依赖注入（DI）的？

答：控制反转 (Inversion of Control， IoC)是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则：“Don’t call me, we will call you”。依赖注入（Dependency Injection，DI）的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。

举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法(构造器或setter方法)，将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。

 

134、请写出Spring 中IoC的实现机制。

答：Spring中可以通过setter方法注入和构造方法注入实现IoC。

 

135、你的项目选择使用Spring框架的原因是什么？

答：

A.Spring提供了企业级开发的一站式选择，有大量的功能模块可供选择，并且可以根据项目的需要自由取舍。Spring通过POJO简化了JavaEE开发，低侵入式的编程提供了代码的持续集成能力和易测试性。

B.Spring框架的核心功能是依赖注入（DI）。DI使得代码的单元测试更加方便、系统更好维护、代码也更加灵活。DI代码自身很容易测试，通过构建实现了应用所需的接口的“模拟”对象就可以进行功能的黑盒测试。DI代码也更容易复用，因为其“被依赖的”功能封装在在定义良好的接口中，允许其他对象根据需要将其插入到所需的对象中，这些对象是在其他应用平台中进行配置的。DI使代码更加灵活，由于其天生的松耦合性，它允许程序员仅需考虑自己所需的接口和其他模块暴露出来的接口来就可以决定对象之间如何关联。

C.Spring支持面向切面编程（AOP），允许通过分离应用业务逻辑和系统服务从而进行内聚性的开发。AOP通常用来支持日志、审计、性能和内存监控等功能。

D.Spring还提供了许多实现基本功能的模板类，使得Java EE应用的开发更加容易。例如，JdbcTemplate类和JDBC、JpaTemplate类和JPA，JmsTemplate类和JMS都可以很好地结合起来使用。RestTemplate类非常简洁，使用这个模板的代码的可读性和可维护性也都很好。

E. Spring提供了声明性事务处理，工作调度，身份认证，成熟的Web MVC框架以及和其他框架的集成，例如Hibernate、MyBatis、JasperReports、JSF、Struts、Tapestry、Seam和Quartz等等。

F. SpringBean对象可以通过Terracotta在不同的JVM之间共享。这就允许使用已有的Bean并在集群中共享 ，将Spring应用上下文事件变为分布式事件，还可以通过Spring JMX导出集群Bean，使得Spring应用高可用、集群化。

G.Spring倾向于使用非受检异常（unchecked exceptions）和减少不当try、catch和finally代码块，例如JpaTemplate这样的Spring模板类会负责关闭或释放数据库连接，这避免了潜在的外部资源泄露问题并提高了代码的可读性。

136、给出下面的二叉树先序、中序、后序遍历的序列？
                 A
        |              |
      B               C
  |      |            |
 D      E             F
      |    |
       G    H

答：先序序列：ABDEGHCF；中序序列：DBGEHACF；后序序列：DGHEBFCA。

补充：二叉树也称为二分树，它是树形结构的一种，其特点是每个结点至多有二棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树的遍历序列按照访问根节点的顺序分为先序（先访问根节点，接下来先序访问左子树，再先序访问右子树）、中序（先中序访问左子树，然后访问根节点，最后中序访问右子树）和后序（先后序访问左子树，再后序访问右子树，最后访问根节点）。如果知道一棵二叉树的先序和中序序列或者中序和后序序列，那么也可以还原出该二叉树。

例如，已知二叉树的先序序列为：xefdzmhqsk，中序序列为：fezdmxqhks，那么还原出该二叉树应该如下图所示：
                      X
            |                      |
          E                        H
 |             |            |          |
F              D           Q            S
           |        |                      |
          Z          M                   K

137、你知道的排序算法都哪些？用Java写一个排序系统。

答：稳定的排序算法有：插入排序、选择排序、冒泡排序、鸡尾酒排序、归并排序、二叉树排序、基数排序等；不稳定排序算法包括：希尔排序、堆排序、快速排序等。

下面是关于排序算法的一个列表：


下面按照策略模式给出一个排序系统，实现了冒泡、归并和快速排序。

Sorter.java

[java] view plaincopy在CODE上查看代码片派生到我的代码片

~~~java
    package com.jackfrued.util;  
       
    import java.util.Comparator;  
       
    /** 
     * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) 
     * @author骆昊 
     * 
     */  
    public interfaceSorter {  
        
       /** 
        * 排序 
        * @param list 待排序的数组 
        */  
       public <T extends Comparable<T>>voidsort(T[] list);  
        
       /** 
        * 排序 
        * @param list 待排序的数组 
        * @param comp 比较两个对象的比较器 
        */  
       public <T> void sort(T[] list,Comparator<T> comp);  
    }  


 

BubbleSorter.java

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.util;  
       
    import java.util.Comparator;  
       
    /** 
     * 冒泡排序 
     * @author骆昊 
     * 
     */  
    public classBubbleSorter implements Sorter {  
       
       @Override  
       public <T extends Comparable<T>>voidsort(T[] list) {  
          boolean swapped = true;  
          for(int i = 1; i < list.length && swapped;i++) {  
            swapped= false;  
            for(int j = 0; j < list.length - i; j++) {  
               if(list[j].compareTo(list[j+ 1]) > 0 ) {  
                  Ttemp = list[j];  
                  list[j]= list[j + 1];  
                  list[j+ 1] = temp;  
                  swapped= true;  
               }  
            }  
          }  
       }  
       
       @Override  
       public <T> void sort(T[] list,Comparator<T> comp) {  
          boolean swapped = true;  
          for(int i = 1; i < list.length && swapped;i++) {  
            swapped= false;  
            for(int j = 0; j < list.length - i; j++) {  
               if(comp.compare(list[j],list[j + 1]) > 0 ) {  
                  Ttemp = list[j];  
                  list[j]= list[j + 1];  
                  list[j+ 1] = temp;  
                  swapped= true;  
               }  
            }  
          }  
       }   
    }  


 

MergeSorter.java

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.util;  
       
    import java.util.Comparator;  
       
    /** 
     * 归并排序 
     * 归并排序是建立在归并操作上的一种有效的排序算法。 
     * 该算法是采用分治法（divide-and-conquer）的一个非常典型的应用， 
     * 先将待排序的序列划分成一个一个的元素，再进行两两归并， 
     * 在归并的过程中保持归并之后的序列仍然有序。 
     * @author骆昊 
     * 
     */  
    public classMergeSorter implements Sorter {  
       
       @Override  
       public <T extends Comparable<T>>voidsort(T[] list) {  
          T[]temp = (T[]) newComparable[list.length];  
          mSort(list,temp, 0, list.length- 1);  
       }  
        
       private <T extends Comparable<T>>voidmSort(T[] list, T[] temp, int low, inthigh) {  
          if(low == high) {  
            return ;  
          }  
          else {  
            int mid = low + ((high -low) >> 1);  
            mSort(list,temp, low, mid);  
            mSort(list,temp, mid + 1, high);  
            merge(list,temp, low, mid + 1, high);  
          }  
       }  
        
       private <T extends Comparable<T>>voidmerge(T[] list, T[] temp, int left, intright, intlast) {  
          int j = 0;   
            int lowIndex = left;   
           int mid = right - 1;   
            int n = last - lowIndex + 1;   
            while (left <= mid && right <= last){   
                if (list[left].compareTo(list[right]) < 0){   
                    temp[j++] = list[left++];   
                } else {   
                    temp[j++] = list[right++];   
                }   
            }   
            while (left <= mid) {   
                temp[j++] = list[left++];   
            }   
            while (right <= last) {   
                temp[j++] = list[right++];   
            }   
            for (j = 0; j < n; j++) {   
                list[lowIndex + j] = temp[j];   
            }   
       }  
       
       @Override  
       public <T> void sort(T[] list,Comparator<T> comp) {  
          T[]temp = (T[]) newComparable[list.length];  
          mSort(list,temp, 0, list.length- 1, comp);  
       }  
        
       private <T> void mSort(T[] list, T[]temp, intlow, inthigh, Comparator<T> comp) {  
          if(low == high) {  
            return ;  
          }  
          else {  
            int mid = low + ((high -low) >> 1);  
            mSort(list,temp, low, mid, comp);  
            mSort(list,temp, mid + 1, high, comp);  
            merge(list,temp, low, mid + 1, high, comp);  
          }  
       }  
        
       private <T> void merge(T[] list, T[]temp, intleft, intright, intlast, Comparator<T> comp) {  
          int j = 0;   
            int lowIndex = left;   
            int mid = right - 1;   
            int n = last - lowIndex + 1;   
            while (left <= mid && right <= last){   
                if (comp.compare(list[left], list[right]) <0) {   
                    temp[j++] = list[left++];   
                } else {   
                    temp[j++] = list[right++];   
                }   
            }   
            while (left <= mid) {   
                temp[j++] = list[left++];   
            }   
            while (right <= last) {   
                temp[j++] = list[right++];   
            }   
            for (j = 0; j < n; j++) {   
                list[lowIndex + j] = temp[j];   
            }   
       }  
       
    }  


 

QuickSorter.java

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.util;  
       
    import java.util.Comparator;  
       
    /** 
     * 快速排序 
     * 快速排序是使用分治法（divide-and-conquer）依选定的枢轴 
     * 将待排序序列划分成两个子序列，其中一个子序列的元素都小于枢轴， 
     * 另一个子序列的元素都大于或等于枢轴，然后对子序列重复上面的方法， 
     * 直到子序列中只有一个元素为止 
     * @author Hao 
     * 
     */  
    public classQuickSorter implements Sorter {  
       
       @Override  
       public <T extends Comparable<T>>voidsort(T[] list) {  
          quickSort(list,0, list.length- 1);  
       }  
       
       @Override  
       public <T> void sort(T[] list,Comparator<T> comp) {  
          quickSort(list,0, list.length- 1, comp);  
       }  
       
       private <T extends Comparable<T>>voidquickSort(T[] list, int first, intlast) {  
          if (last > first) {  
            int pivotIndex =partition(list, first, last);  
            quickSort(list,first, pivotIndex - 1);  
            quickSort(list,pivotIndex, last);  
          }  
       }  
        
       private <T> void quickSort(T[] list, int first, int last,Comparator<T> comp) {  
          if (last > first) {  
            int pivotIndex =partition(list, first, last, comp);  
            quickSort(list,first, pivotIndex - 1, comp);  
            quickSort(list,pivotIndex, last, comp);  
          }  
       }  
       
       private <T extends Comparable<T>>intpartition(T[] list, int first, intlast) {  
          Tpivot = list[first];  
          int low = first + 1;  
          int high = last;  
       
          while (high > low) {  
            while (low <= high&& list[low].compareTo(pivot) <= 0) {  
               low++;  
            }  
            while (low <= high&& list[high].compareTo(pivot) >= 0) {  
               high--;  
            }  
            if (high > low) {  
               Ttemp = list[high];  
               list[high]= list[low];  
               list[low]= temp;  
            }  
          }  
       
          while (high > first&& list[high].compareTo(pivot) >= 0) {  
            high--;  
          }  
          if (pivot.compareTo(list[high])> 0) {  
            list[first]= list[high];  
            list[high]= pivot;  
            return high;  
          }  
          else {  
            return low;  
          }  
       }  
       
       private <T> int partition(T[] list, int first, int last,Comparator<T> comp) {  
          Tpivot = list[first];  
          int low = first + 1;  
          int high = last;  
       
          while (high > low) {  
            while (low <= high&& comp.compare(list[low], pivot) <= 0) {  
               low++;  
            }  
            while (low <= high&& comp.compare(list[high], pivot) >= 0) {  
               high--;  
            }  
            if (high > low) {  
               Ttemp = list[high];  
                list[high] = list[low];  
               list[low]= temp;  
            }  
          }  
       
          while (high > first&& comp.compare(list[high], pivot) >= 0) {  
            high--;  
          }  
          if (comp.compare(pivot,list[high]) > 0) {  
            list[first]= list[high];  
            list[high]= pivot;  
            return high;  
          }  
          else {  
            return low;  
          }  
       }  
        
    }  

~~~

138、写一个二分查找（折半搜索）的算法。

答：折半搜索，也称二分查找算法、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    package com.jackfrued.util;  
       
    import java.util.Comparator;  
       
    public classMyUtil {  
       
       public static <T extends Comparable<T>>intbinarySearch(T[] x, T key) {  
          return binarySearch(x,0, x.length- 1, key);  
       }  
        
       public static <T> int binarySearch(T[] x, T key, Comparator<T> comp) {  
          int low = 0;  
          int high = x.length - 1;  
          while (low <= high) {  
              int mid = (low + high) >>> 1;  
              int cmp = comp.compare(x[mid], key);  
              if (cmp < 0) {  
                low= mid + 1;  
              }  
              else if (cmp > 0) {  
                high= mid - 1;  
              }  
              else {  
                return mid;  
              }  
          }  
          return -1;  
       }  
        
       private static<T extends Comparable<T>>intbinarySearch(T[] x, int low, inthigh, T key) {  
          if(low <= high) {  
            int mid = low + ((high -low) >> 1);  
            if(key.compareTo(x[mid])== 0) {  
               return mid;  
            }  
            else if(key.compareTo(x[mid])< 0) {  
               return binarySearch(x,low, mid - 1, key);  
            }  
            else {  
               return binarySearch(x,mid + 1, high, key);  
            }  
          }  
          return -1;  
       }  
    }  


说明：两个版本一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2的方式，因为加法运算可能导致整数越界，这里应该使用一下三种方式之一：low+ (high – low) / 2或low + (high – low) >> 1或（low + high） >>> 1（注：>>>是逻辑右移，不带符号位的右移）

 

139、统计一篇英文文章中单词个数。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    import java.io.FileReader;  
       
    public class WordCounting {  
       
       publicstatic void main(String[] args) {  
         try(FileReader fr = new FileReader("a.txt")) {  
            intcounter = 0;  
            booleanstate = false;  
            intcurrentChar;  
            while((currentChar= fr.read()) != -1) {  
              if(currentChar== ' ' || currentChar == '\n'  
                 ||currentChar == '\t' || currentChar == '\r') {  
                 state= false;  
              }  
              elseif(!state) {  
                 state= true;  
                 counter++;  
              }  
            }  
            System.out.println(counter);  
         }  
         catch(Exceptione) {  
            e.printStackTrace();  
         }  
       }  
    }  


补充：这个程序可能有很多种写法，这里选择的是Dennis M. Ritchie和Brian W. Kernighan老师在他们不朽的著作《The C Programming Language》中给出的代码，向两位老师致敬。下面的代码也是如此。

 

140、输入年月日，计算该日期是这一年的第几天。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    import java.util.Scanner;  
       
    public classDayCounting {  
       
       public static void main(String[] args) {  
          int[][] data = {  
               {31,28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},  
               {31,29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}  
          };  
          Scannersc = newScanner(System.in);  
          System.out.print("请输入年月日(1980 11 28): ");  
          int year = sc.nextInt();  
          int month = sc.nextInt();  
          int date = sc.nextInt();  
          int[] daysOfMonth =  
    data[(year % 4 == 0 && year % 100 != 0 || year % 400 == 0)?1 : 0];  
          int sum = 0;  
          for(int i = 0; i < month -1; i++) {  
            sum+= daysOfMonth[i];  
          }  
          sum+= date;  
          System.out.println(sum);  
          sc.close();  
       }  
    }  


 

141、约瑟夫环：15个基督教徒和15个非教徒在海上遇险，必须将其中一半的人投入海中，其余的人才能幸免于难，于是30个人围成一圈，从某一个人开始从1报数，报到9的人就扔进大海，他后面的人继续从1开始报数，重复上面的规则，直到剩下15个人为止。结果由于上帝的保佑，15个基督教徒最后都幸免于难，问原来这些人是怎么排列的，哪些位置是基督教徒，哪些位置是非教徒。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classJosephu {  
       private static final int DEAD_NUM = 9;  
        
       public static void main(String[] args) {  
          boolean[] persons = new boolean[30];  
          for(int i = 0; i < persons.length; i++) {  
            persons[i]= true;  
          }  
           
          int counter = 0;  
          int claimNumber = 0;  
          int index = 0;  
          while(counter < 15) {  
            if(persons[index]) {  
               claimNumber++;  
               if(claimNumber == DEAD_NUM) {  
                  counter++;  
                  claimNumber= 0;  
                  persons[index]= false;  
               }  
            }  
            index++;  
            if(index >= persons.length) {  
               index= 0;  
             }  
          }  
          for(boolean p : persons) {  
            if(p) {  
               System.out.print("基");  
            }  
            else {  
               System.out.print("非");  
            }  
          }  
       }  
    }  


 

142、回文素数：所谓回文数就是顺着读和倒着读一样的数(例如：11，121，1991…)，回文素数就是既是回文数又是素数(只能被1和自身整除的数)的数。编程找出11～9999之间的回文素数。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classPalindromicPrimeNumber {  
       
       public static void main(String[] args) {  
          for(int i = 11; i <= 9999;i++) {  
            if(isPrime(i)&& isPalindromic(i)) {  
               System.out.println(i);  
            }  
          }  
       }  
        
       public static boolean isPrime(int n) {  
          for(int i = 2; i <= Math.sqrt(n);i++) {  
             if(n % i == 0) {  
               return false;  
            }  
          }  
          return true;  
       }  
        
       public static boolean isPalindromic(int n) {  
          int temp = n;  
          int sum = 0;  
          while(temp > 0) {  
            sum= sum * 10 + temp % 10;  
            temp/= 10;  
          }  
          return sum == n;  
       }  
    }  


 

143、全排列：给出五个数字12345的所有排列。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classFullPermutation {  
       
       public static void perm(int[] list) {  
          perm(list,0);  
       }  
       
       private static void perm(int[] list, int k) {  
          if (k == list.length) {  
            for (int i = 0; i < list.length; i++) {  
               System.out.print(list[i]);  
            }  
             System.out.println();  
          }else{  
            for (int i = k; i < list.length; i++) {  
               swap(list,k, i);  
               perm(list,k + 1);  
               swap(list,k, i);  
            }  
          }  
       }  
       
       private static void swap(int[] list, int pos1, int pos2) {  
          int temp = list[pos1];  
          list[pos1]= list[pos2];  
          list[pos2]= temp;  
       }  
       
       public static void main(String[] args) {  
          int[] x = {1, 2, 3, 4, 5};  
          perm(x);  
       }  
    }  
       


144、对于一个有N个整数元素的一维数组，找出它的子数组（数组中下标连续的元素组成的数组）之和的最大值。

答：下面给出几个例子（最大子数组用粗体表示）：

1) 数组：{ 1, -2, 3,5, -3, 2 }，结果是：8

2) 数组：{ 0, -2, 3, 5, -1, 2 }，结果是：9

3) 数组：{ -9, -2,-3, -5, -3 }，结果是：-2

可以使用动态规划的思想求解：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classMaxSum {  
       
       private static int max(int x, int y) {  
          return x > y? x: y;  
       }  
        
       public static int maxSum(int[] array) {  
          int n = array.length;  
          int[] start = new int[n];  
          int[] all = new int[n];  
          all[n- 1] = start[n - 1] = array[n - 1];  
          for(int i = n - 2; i >= 0;i--) {  
            start[i]= max(array[i], array[i] + start[i + 1]);  
            all[i]= max(start[i], all[i + 1]);  
          }  
          return all[0];  
       }  
        
       public static void main(String[] args) {  
          int[] x1 = { 1, -2, 3, 5,-3, 2 };  
          int[] x2 = { 0, -2, 3, 5,-1, 2 };  
          int[] x3 = { -9, -2, -3,-5, -3 };  
          System.out.println(maxSum(x1));   // 8  
          System.out.println(maxSum(x2));   // 9  
          System.out.println(maxSum(x3));   //-2  
       }  
    }  


 

145、用递归实现字符串倒转

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classStringReverse {  
       
       public static String reverse(StringoriginStr) {  
          if(originStr == null || originStr.length()== 1) {  
            return originStr;  
          }  
          return reverse(originStr.substring(1))+ originStr.charAt(0);  
       }  
        
       public static void main(String[] args) {  
          System.out.println(reverse("hello"));  
       }  
    }  
       


146、输入一个正整数，将其分解为素数的乘积。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classDecomposeInteger {  
       
       private static List<Integer> list = newArrayList<Integer>();  
        
       public static void main(String[] args) {  
          System.out.print("请输入一个数: ");  
          Scannersc = newScanner(System.in);  
          int n = sc.nextInt();  
          decomposeNumber(n);  
          System.out.print(n + " = ");  
          for(int i = 0; i < list.size() - 1; i++) {  
            System.out.print(list.get(i) + " * ");  
          }  
          System.out.println(list.get(list.size() - 1));  
       }  
        
       public static void decomposeNumber(int n) {  
          if(isPrime(n)) {  
            list.add(n);  
            list.add(1);  
          }  
          else {  
            doIt(n,(int)Math.sqrt(n));  
          }  
       }  
        
       public static void doIt(int n, int div) {  
          if(isPrime(div)&& n % div == 0) {  
            list.add(div);  
            decomposeNumber(n/ div);  
          }  
          else {  
            doIt(n,div - 1);  
          }  
       }  
       
       public static boolean isPrime(int n) {  
          for(int i = 2; i <= Math.sqrt(n);i++) {  
            if(n % i == 0) {  
               return false;  
            }  
          }  
          return true;  
       }  
    }  


 

147、一个有n级的台阶，一次可以走1级、2级或3级，问走完n级台阶有多少种走法。

答：可以通过递归求解。

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classGoSteps {  
       
       public static int countWays(int n) {   
            if(n < 0) {   
                return 0;   
            }   
            else if(n == 0) {   
                return 1;   
            }   
            else {   
                return countWays(n - 1) + countWays(n - 2) + countWays(n -3);   
            }   
       }   
           
       publicstaticvoidmain(String[] args) {   
            System.out.println(countWays(5));   // 13    
       }   
    }  


 

148、写一个算法判断一个英文单词的所有字母是否全都不同（不区分大小写）。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classAllNotTheSame {  
       
       public static boolean judge(String str) {  
          Stringtemp = str.toLowerCase();  
          int[] letterCounter = new int[26];  
          for(int i = 0; i <temp.length(); i++) {  
            int index = temp.charAt(i)- 'a';  
            letterCounter[index]++;  
            if(letterCounter[index]> 1) {  
               return false;  
            }  
          }  
          return true;  
       }  
        
       public static void main(String[] args) {  
          System.out.println(judge("hello"));  
          System.out.print(judge("smile"));  
       }  
    }  



149、有一个已经排好序的整数数组，其中存在重复元素，请将重复元素删除掉，例如，A= [1, 1, 2, 2, 3]，处理之后的数组应当为A= [1, 2, 3]。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    import java.util.Arrays;  
       
    public classRemoveDuplication {  
       
       public static int[] removeDuplicates(int a[]) {   
            if(a.length <= 1) {   
                return a;   
            }   
            int index = 0;   
            for(int i = 1; i < a.length; i++) {   
                if(a[index] != a[i]) {   
                    a[++index] = a[i];   
                }   
            }   
            int[] b = new int[index + 1];   
            System.arraycopy(a, 0, b, 0, b.length);   
            return b;   
       }   
           
       publicstaticvoidmain(String[] args) {   
            int[] a = {1, 1, 2, 2, 3};   
            a = removeDuplicates(a);   
            System.out.println(Arrays.toString(a));   
       }   
    }  


 

150、给一个数组，其中有一个重复元素占半数或半数以上，找出这个元素。

答：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public classFindMost {  
       
       public static <T> T find(T[] x){  
          Ttemp = null;  
          for(int i = 0, nTimes = 0; i< x.length;i++) {  
            if(nTimes == 0) {  
               temp= x[i];  
               nTimes= 1;  
            }  
            else {  
               if(x[i].equals(temp)) {  
                  nTimes++;  
               }  
               else {  
                  nTimes--;  
               }  
            }  
          }  
          return temp;  
       }  
        
       public static void main(String[] args) {  
          String[]strs = {"hello","kiss","hello","hello","maybe"};  
          System.out.println(find(strs));  
       }  
    }  