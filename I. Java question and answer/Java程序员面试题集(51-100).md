Java程序员面试题集（51-100）

51、类ExampleA 继承Exception，类ExampleB 继承ExampleA。

有如下代码片断：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    try{  
    thrownew ExampleB(“b”)；  
    }catch（ExampleAe）{  
    System.out.printfln（“ExampleA”）；  
    }catch（Exceptione）{  
    System.out.printfln（“Exception”）；  
    }  


输出的内容应该是：

A：ExampleA B：Exception C无输出

答：输出为A。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）

 

52、List、Set、Map 是否继承自Collection 接口？

答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。

 

53、说出ArrayList、Vector、LinkedList 的存储性能和特性？

答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。

 

54、Collection 和Collections 的区别？

答：Collection 是一个接口，它是Set、List等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。

 

55、List、Map、Set 三个接口，存取元素时，各有什么特点？

答：List以特定索引来存取元素，可有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希码和排序树的两种实现版本，基于哈希码的版本存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

 

56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？

答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则。

 

57、sleep()和wait()有什么区别?

答：sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），以为调用sleep 不会释放对象锁。wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。

 

58、sleep()和yield()有什么区别?

答：

① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；

③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；

④ sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。

 

59、当一个线程进入一个对象的synchronized方法后，其它线程是否可进入此对象的其它方法？

答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。

 

60、请说出与线程同步相关的方法。

答：

1)wait():使一个线程处于等待状态，并且释放所持有的对象的锁；

2)sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；

3)notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；

4)notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争；

5)JDK 1.5通过Lock接口提供了显式(explicit)的锁机制，增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁(unlock())的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；

6)JDK 1.5还提供了信号量(semaphore)机制，信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须从得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。

 

61、编写多线程程序有几种实现方式？

答：多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为。

 

62、synchronized关键字的用法？

答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。

 

63、举例说明同步和异步。

答：如果系统中存在临界资源（每次只允许一个线程访问的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的悲观锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。

 

64、启动一个线程是用run()还是start()方法?

答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

 

65、什么是线程池（thread pool）？

答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是"池化资源"技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

Java中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：

ü  newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

ü  newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

ü  newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

ü  newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

ü  newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。

 

66、线程的基本状态以及状态之间的关系？

答：

 


67、简述synchronized 和java.util.concurrent.locks.Lock的异同？

答：主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 块中释放（这是释放外部资源的最好的地方）。

 

68、Java中如何实现序列化，有什么意义？

答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。

要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。

 

69、Java 中有几种类型的流？

答：字节流，字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。

补充：关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。

 

70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。

答：代码如下：

[java] view plaincopy在CODE上查看代码片派生到我的代码片

    public int countWords(String file, String find)throws Exception  
    {  
    try(Reader in = new FileReader(file)) {  
    int count = 0;  
    intc;  
       
    while ((c = in.read()) != -1) {  
    while (c == find.charAt(0)) {  
    for (int i = 1; i < find.length(); i++) {  
    c = in.read();  
    if (c != find.charAt(i)) break;  
    if (i == find.length() - 1) count++;  
    }  
    }  
    }  
    }  
    return count;  
    }  


注意：这里用到了JDK 1.7的TWR（Try-With-Resources），这种写法让代码更加紧凑精炼。



71、UML是什么？UML中有哪些图？

答：UML是统一建模语言，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程。UML包括了用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等图形符号用来描述软件系统部分或全部的静态结构和动态结构。

 

72、写一个单例类。

答：单例模式主要作用是保证在Java应用程序中，一个类只有一个实例存在。下面给出两种不同形式的单例：

第一种形式：饿汉式单例

public class Singleton {
private Singleton(){}
private static Singleton instance = new Singleton();
public static Singleton getInstance(){
return instance;
}
}



第二种形式：懒汉式单例

public class Singleton {
private static Singleton instance = null;
public static synchronized Singleton getInstance(){
if (instance==null)
instance＝newSingleton();
return instance;
}
}



单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。

 

73、说说你所熟悉或听说过的设计模式以及你对设计模式的看法。
答：在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式（Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式））。

所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。

74、Java企业级开发中常用的设计模式有哪些？

答： 按照分层开发的观点，可以将应用划分为：表示层、业务逻辑层和持久层，每一层都有属于自己类别的设计模式。

表示层设计模式：

1)Interceptor Filter：拦截过滤器，提供请求预处理和后处理的方案，可以对请求和响应进行过滤。

2)Front Controller：通过中央控制器提供请求管理和处理，管理内容读取、安全性、视图管理和导航等功能。

3)View Helper：视图帮助器，负责将显示逻辑和业务逻辑分开。显示的部分放在视图组件中，业务逻辑代码放在帮助器中，典型的功能是内容读取、验证与适配。

4)Composite View：复合视图

业务逻辑层设计模式：

1)Business Delegate：业务委托，减少表示层和业务逻辑层之间的耦合。

2)Value Object：值对象，解决层之间交换数据的开销问题。

3)Session Façade：会话门面，隐藏业务逻辑组件的细节，集中工作流程。

4)Value Object Assembler：灵活的组装不同的值对象

5)Value List Handler：提供执行查询和处理结果的解决方案，还可以缓存查询结果，从而达到提升性能的目的。

6)Service Locator：服务定位器，可以查找、创建和定位服务工厂，封装其实现细节，减少复杂性，提供单个控制点，通过缓存提高性能。

持久层设计模式：

1)Data Access Object：数据访问对象，以面向对象的方式完成对数据的增删改查。

 

75、你在开发中都用到了那些设计模式？用在什么场合？

答：面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：

1)工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。

2)代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。

3)适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。

4)模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。

 

76、XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？

答：XML文档定义分为DTD和Schema两种形式；其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析。对XML的解析主要有DOM（文档对象模型）、SAX、StAX（JDK 1.6中引入的新的解析XML的方式，StreamingAPI for XML） 等，其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM 的树结构所造成的，这种结构占用的内存较多，而且DOM 必须在解析文件之前把整个文档装入内存,适合对XML 的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML 的顺序访问；如其名称所暗示的那样，StAX把重点放在流上。实际上，StAX与其他方法的区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。

 

77、你在项目中哪些地方用到了XML？

答:XML的主要作用有两个方面：数据交换（曾经被称为业界数据交换的事实标准，现在此项功能在很多时候都被JSON取代）和信息配置。在做数据交换平台时，将数据用标签组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理。目前很多软件都使用XML来存储器配置文件，项目开始时通常也会将作为配置的硬代码（hard code）写在XML文件中。

 

78、在进行数据库编程时，连接池有什么作用？

答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，再加上网络延迟，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。

 

79、什么是DAO模式？

答：DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作。为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。

 

80、什么是ORM？

答：对象关系映射（Object—Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将Java程序中的对象自动持久化到关系数据库中，其本质上就是将数据从一种形式转换到另外一种形式。

 

81、JDBC中如何进行事务处理？

答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，较新的JDBC标准还引入了Savepoint（保存点）的概念，允许事务回滚到指定的保存点。

 

82、 事务的ACID是指什么？

答：

1)原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；

2)一致性(Consistent)：事务结束后系统状态是一致的；

3)隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；

4)持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。

  

83、Statement和PreparedStatement有什么区别？哪个性能更好？

答： 与Statement相比，1PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；2PreparedStatement中的SQL语句是可以带参数的；3当批量处理SQL时或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同语句时就会很快。

补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库系统中，一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。但是调用存储过程可能会影响数据库的移植，因为每种数据库的存储过程在书写上存在许多差别。

 

84、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？

答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象指定每次抓取数据的大小（fetch size）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理（batch）。

 

85、JDBC能否处理Blob和Clob？

答： Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。

86、Struts 2中，Action通过什么方式获得用户从页面输入的数据，又是通过什么方式把其自身的数据传给视图的？

答：Action从页面获取数据有三种方式：

1)通过Action属性接受参数

2)通过域模型获取参数

3)通过模型驱动获取参数 （ModelDriven<T>）

Action将数据存入值栈(Value Stack)中，视图可以通过表达式语言（EL）从值栈中获取数据。

 

87、简述Struts 2是如何实现MVC架构模式的。

答：MVC架构模式要求应用程序的输入、处理和输出三者分离，将系统分成模型（Model）、视图（View）、控制器（Controller）三个部分，通过控制器实现模型和视图的解耦合，使得应用程序的开发和维护变得容易，如下图所示。其中，模型代表了应用程序的数据和处理这些数据的规则，同时还可以为视图提供的查询保存相关的状态，通常由JavaBean来实现，模型的代码写一次就可以被多个视图重用；视图用来组织模型的内容，它从模型中获得数据，并将数据展现给用户，在Struts 2中通常由JSP页面、Freemarker模板等来实现；控制器负责从客户端接受请求并将其转换为某种行为，行为完成后再选择一个视图来呈现给用户，控制器本身不需要输出任何内容，它只是接收请求并决定调用哪个模型组件去处理请求，StrutsPrepareAndExecuteFilter过滤器是Struts 2中的核心，它和一系列的Action构成了Struts 2中的控制器。


图-1 MVC架构模式图

88、阐述Struts 2如何实现用户输入验证。在你做过的项目中使用的是那种验证方式，为什么选择这种方式？

答：Struts 2可以使用手动验证和自动验证框架实现用户输入验证。自动验证框架是将对输入的验证规则放在XML文件中，这种方式比较灵活，可以在不修改代码的情况下修改验证的规则。

 

89、阐述Struts 2中的Action如何编写？Action是否采用了单例？

答：Struts2的Action有三种写法：

1)POJO

2)实现Action接口重写execute()方法

3)继承ActionSupport类

Action没有像Servlet一样使用单实例多线程的工作方式，很明显，每个Action要接收不同用户的请求参数，这就意味着Action是有状态的，因此在设计上使用了每个请求对应一个Action的处理方式。

 

90、Struts 2中的Action并没有直接收到用户的请求，那它为什么可以处理用户的请求，又凭什么知道一个请求到底交给哪个Action来处理？

答：Struts2的核心过滤器接收到用户请求后，会对用户的请求进行简单的预处理(例如解析、封装参数)，然后通过反射来创建Action实例，并调用Action中指定的方法来处理用户请求。

要决定请求交给哪一个Action来处理有两种方式：1利用配置文件：可以在配置文件中通过<action>标签配置和请求对应的Action类以及要调用的方法；2利用约定：Struts2中可以使用约定(convention)插件，例如约定xxx总是对应XxxAction，这是对约定优于配置理念的践行。

 

91、你经常用到的Struts 2常量配置有哪些？

答：

1)struts.i18n.encoding– 指定默认编码

2)struts.objectFactory/ struts.objectFactory.spring.autoWire – 对象工厂 / Spring的自动装配方式(名字、类型)

3)struts.devMode– 是否使用开发模式

4)struts.locale– 指定默认区域，默认值是en_US

5)struts.i18n.resources– 国际化使用的资源文件

6)struts.enable.DynamicMethodInvocation– 是否允许动态方法调用

 

92、简述Struts2的异常处理机制。

答：Struts 2提供了声明式的异常处理机制，可以在配置文件中加入如下代码：

<global-exception-mappings>

<exception-mapping exception=”…” result=”…”/>

</global-exception-mappings>

 

93、说一下你对约定优于配置（CoC）的理解。

答：约定优于配置(convention over configuration)，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量。本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为products_sold，才需写有关这个名字的配置。如果您所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式。遵循约定虽然损失了一定的灵活性，不能随意安排目录结构，不能随意进行函数命名，但是却能减少配置。更重要的是，遵循约定可以帮助开发人员遵守构建标准，包括各种命名的规范。

 

94、Struts2中如何实现I18N？

答：首先，为不同语言地区编写不同的资源文件；然后在Struts 2配置文件中配置struts.i18n.custom.resources常量；在Action中可以通过调用getText()方法读取资源文件获取国际化资源。

 

95、简述拦截器的工作原理以及你在项目中使用过哪些自定义拦截器。

答：Struts 2中定义了拦截器的接口以及默认实现，实现了Interceptor接口或继承了AbstractInterceptor的类可以作为拦截器。接口中的init()方法在拦截器被创建后立即被调用，它在拦截器的生命周期内只被调用一次，可以在该方法中对相关资源进行必要的初始化。每拦截一个请求，intercept()方法就会被调用一次。destory()方法将在拦截器被销毁之前被调用, 它在拦截器的生命周期内也只被调用一次。

项目中使用过的有权限拦截器、执行时间拦截器、令牌拦截器等。

 

96、如何在Struts2中使用Ajax功能？

答：以下是Struts 2中实现Ajax的可选方式：

1)JSON plugin+ jQuery

2)DOJO plugin

3)DWR (DirectWeb Remoting)

 

97、谈一下拦截器和过滤器的区别。

答：拦截器和过滤器都可以用来实现横切关注功能，其区别主要在于：

1)拦截器是基于Java反射机制的，而过滤器是基于接口回调的。

2)过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器。

3)拦截器只能对Action请求起作用，而过滤器可以对所有请求起作用。

4)拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。

 

98、谈一下Struts 1和Struts2的区别。

不同点
	

Struts 1
	

Struts 2

Action 类
	

要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口。
	

Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts 2提供一个ActionSupport类去作为Action的父类，但不是必须的，任何有execute方法的POJO对象都可以用作Struts 2的Action对象。

线程模式
	

Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。
	

Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，Servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）

Servlet依赖
	

Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和HttpServletResponse 被传递给execute方法。
	

Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。

可测性
	

Action的一个主要问题是execute方法暴露了servlet API（这使得测试要依赖于容器）。
	

Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。

捕获输入
	

使用ActionForm对象捕获输入。所有的ActionForm必须继承一个基类。因为其他JavaBean不能用作ActionForm，开发者经常创建多余的类捕获输入。
	

Struts2可以通过Action的属性、域模型或模型驱动等方式实现输入捕获，而且还自带了默认的类型转换机制。

表达式语言
	

整合了JSTL，因此使用JSTL EL。这种EL有基本对象图遍历，但是对集合和索引属性的支持较弱。
	

可以使用JSTL，但是也支持一个更强大和灵活的表达式语言 – OGNL（坦白的说这是一个很垃圾又没有效率的表达式语言，因为前不久曝出的Struts 2高危漏洞就是由OGNL引起的）

类型转换
	

ActionForm 属性通常都是String类型。Struts1使用Commons-Beanutils进行类型转换。每个类一个转换器，对每一个实例来说是不可配置的。
	

使用OGNL进行类型转换。提供基本和常用对象的转换器。

 

99、谈一下你的项目选择Struts 2的理由

答：1Action是POJO，没有依赖Servlet API，具有良好的可测试性；2强大的拦截器简化了开发的复杂度；3支持多种表现层技术：JSP、Freemarker等等；4灵活的验证方式；5国际化(I18N)支持；6声明式异常管理；7通过JSON插件简化Ajax；8通过Spring插件跟Spring整合。

补充：有人为选择和评判Web框架提出了20条标准，包括：开发人员的工作效率（能用1-5天搭建一个CRUD页面吗）、开发人员的看法（用起来有意思吗）、学习曲线（学了一个星期或一个月后能干活吗）、项目健康状况（项目陷入绝境了吗）、开发人员的充足性（能找到经验丰富的开发人员吗）、就业趋势（将来能招到人吗）、模板化（遵循DRY原则吗）、组件（自带日期选择器之类的控件吗）、Ajax（是否支持异步调用和局部刷新）、插件或附加项（能加入Facebook集成之类的功能吗）、扩展性（默认的控制处理的并发用户数能到500+吗）、测试支持（能够做测试驱动的开发吗）、I18N和L10N（有多国语言、地域支持吗）、校验（能轻松校验用户输入并迅速反馈吗）、多编程语言支持（能够同时使用多种语言开发吗）、文档的质量（常见的用例和问题都在文档中有体现吗）、出版的图书（有没有行业专家使用了它并分享了自己的使用经验）、REST支持（能按HTTP协议的设计宗旨使用该协议吗）、移动支持（是否很容易就能支持Android、iOS和其他移动智能终端）、风险程度（能不能做大型项目）。很明显，Java其实算不上最优化的Web开发语言，但是它却满足了这20条中的很多，尤其是充足的开发人员、成熟的解决方案这两点。

 

100、Struts 2中如何访问HttpServletRequest、HttpSession和ServletContext三个域对象

答：有两种方式：

1)通过ServletActionContext的方法获得；

2)通过ServletRequestAware、SessionAware和ServletContextAware接口注入。

